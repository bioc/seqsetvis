% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions_signal_plots.R
\name{ssvSignalHeatmap.ClusterBars}
\alias{ssvSignalHeatmap.ClusterBars}
\title{heatmap style representation of membership table.
instead of clustering, each column is sorted starting from the left.}
\usage{
ssvSignalHeatmap.ClusterBars(
  bw_data,
  nclust = 6,
  perform_clustering = c("auto", "yes", "no")[1],
  row_ = "id",
  column_ = "x",
  fill_ = "y",
  facet_ = "sample",
  cluster_ = "cluster_id",
  FUN_format_heatmap = NULL,
  max_rows = 500,
  max_cols = 100,
  fill_limits = NULL,
  clustering_col_min = -Inf,
  clustering_col_max = Inf,
  within_order_strategy = c("hclust", "sort")[2],
  dcast_fill = NA,
  return_data = FALSE,
  return_unassembled_plots = FALSE,
  rel_widths = c(1, 9),
  ...
)
}
\arguments{
\item{bw_data}{a GRanges or data.table of bigwig signal.
As returned from \code{\link{ssvFetchBam}} and \code{\link{ssvFetchBigwig}}}

\item{nclust}{number of clusters}

\item{perform_clustering}{should clustering be done? default is auto.
auto considers if row_ has been ordered by being a factor and if cluster_ is a numeric.}

\item{row_}{variable name mapped to row, likely id or gene name for ngs data. Default is "id" and works with ssvFetch* output.}

\item{column_}{varaible mapped to column, likely bp position for ngs data. Default is "x" and works with ssvFetch* output.}

\item{fill_}{numeric variable to map to fill. Default is "y" and works with ssvFetch* output.}

\item{facet_}{variable name to facet horizontally by. Default is "sample" and works with ssvFetch* output. Set to "" if data is not facetted.}

\item{cluster_}{variable name to use for cluster info. Default is "cluster_id".}

\item{max_rows}{for speed rows are sampled to 500 by default, use Inf to plot full data}

\item{max_cols}{for speed columns are sampled to 100 by default, use Inf to plot full data}

\item{fill_limits}{limits for fill legend.  values will be cropped to this range if set.  Default of NULL uses natural range of fill_.}

\item{clustering_col_min}{numeric minimum for col range considered when clustering, default in -Inf}

\item{clustering_col_max}{numeric maximum for col range considered when clustering, default in Inf}

\item{within_order_strategy}{one of "hclust" or "sort".  if hclust,
hierarchical clustering will be used. if sort, a simple decreasing sort of
rosSums.}

\item{dcast_fill}{value to supply to dcast fill argument. default is NA.}

\item{return_data}{logical.  If TRUE, return value is no longer ggplot and
is instead the data used to generate that plot. Default is FALSE.}

\item{return_unassembled_plots}{logical. If TRUE, return list of heatmap and cluster-bar ggplots.  Can be customized and passed to \code{\link{assemble_heatmap_cluster_bars}}}

\item{rel_widths}{numeric of length 2.  Passed to cowplot::plot_grid.  Default is c(1, 9).}

\item{...}{addtional arguments passed to cowplot::plot_grid}
}
\value{
ggplot heatmap of signal profiles, facetted by sample
}
\description{
Compared to ssvSignalHeatmap, cluster_bars are displayed on the left once instead of for each facet
}
\examples{
#the simplest use
ssvSignalHeatmap.ClusterBars(CTCF_in_10a_profiles_gr)
ssvSignalHeatmap.ClusterBars(CTCF_in_10a_profiles_gr, rel_widths = c(1, 5))

#clustering can be done manually beforehand
clust_dt = ssvSignalClustering(CTCF_in_10a_profiles_gr, nclust = 3)
ssvSignalHeatmap.ClusterBars(clust_dt)
}
