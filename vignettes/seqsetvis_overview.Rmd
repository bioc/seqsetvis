---
title: "The **seqsetvis** package"
author: "Joseph R Boyd"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
    %\VignetteIndexEntry{CTCF binding in breast cancer cell lines: From GEO}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE
)
```

# Abstract
`r Githubpkg("jrboyd/seqsetvis")` is an R package for the visual
comparison of sets of genomic regions (typically ChIP-seq peak calls).  
This covers straightforward overlaps 
suitable for something like a Venn diagram and extends to more sophisticated 
visualization of continous signal data via clustered heatmaps and track-like 
line plots.  

# Features

* Mostly it "just works" with minimal assumed knowledge of R or other 
Bioconductor packages.
* All plots produced are `r CRANpkg("ggplot2")` objects. 
+ easily customized according to user preferences by appending *ggplot2* functions.
+ powerful plot arrangement with with `r CRANpkg("cowplot")`, `r CRANpkg("gridExtra")`, etc.
* Although various plots are implemented, the underlying data are simple in 
structure and easily accessible so **you** can do what **you** want with them.
+ membership table for feature overlaps is just a logical matrix.
+ signal data is stored in a tidy formatted `r CRANpkg("data.table")`, ideal for `r CRANpkg("ggplot2")` visualization.

Although initially designed to focus on peak call sets, *seqsetvis* is flexile and 
accepts any data in *GRanges* format and is therefore flexible enough to work dowstream of 
many genomics tools and packages.  Indeed, set comparison visualizations are genomics 
agnostic and also accept generic data types defining sets.  

# Functions

* `ssv*` - most primary user facing functions are prefixed by ssv
+ `ssvOverlapIntervalSets` - derives sets from a list of GRanges
+ `ssvMakeMembTable` - coerces various ways of defining sets to a membership table
+ `ssvFeature*` - visualizations of set counts and overlaps
+ `ssvSignal*` - visualizations of signal mapped to genomic coordinates in sets context
* utility functions
+ `easyLoad_*` - loads files into a list of GRanges for input into `ssv*` functions
+ `fetch*` - grabs data from .bigwig and .bam files
+ miscellaneous but potentially handy functions such as wrappers for data.table functions.



# Installation and Loading

## From github
One dependency from bioconductor isn't getting installed automatically
```{r bioC missed dependency, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("GenomeInfoDbData")
```

Install devtools if needed
```{r devtools check, eval=FALSE}
if(!require(devtools)){
    install.packages("devtools")    
}
```

Install *seqsetvis* from github
```{r install seqsetvis from github, eval=FALSE}
devtools::install_github("jrboyd/seqsetvis", build_vignettes = TRUE)
```

## Load the library
```{r load seqsetvis}
library(seqsetvis)
```

## Load optional useful libraries
```{r load optional libs, message = FALSE}
library(GenomicRanges)
library(data.table)
```

# Defining sets
*seqsetvis* has several ways of accepting set information.  Since *seqsetvis* was 
originally intended to focus on comparing sets of peak calls, a list of 
*GRanges* or a *GRangesList* is directly supported but there are more
generic alternatives.

## Overlapping a list of *GRanges*
Many functions in *seqsetvis* require some kind of sets definition
as input.  Sets can be defined in one of several ways.  `ssvOverlapIntervalSets()` creates 
a single *GRanges* from a list of *GRanges*
with a logical membership table as metadata columns defining sets.
```{r overlap basic}
olaps = ssvOverlapIntervalSets(CTCF_in_10a_narrowPeak_grs)
head(olaps)
```

`ssvOverlapIntervalSets()` also accepts a *GRangesList* if that's more natural.
```{r overlap GRangesList}
olaps_fromGRangesList = ssvOverlapIntervalSets(GenomicRanges::GRangesList(CTCF_in_10a_narrowPeak_grs))
```

The membership data contained in the metadata columns of `olaps` is  
the data structure *seqsetvis* set overlap functions use internally.  
The S4 method `ssvMakeMembTable()` handles the necessary conversions and 
can be extended 
to accept a new class of data as long as it converts to an already accepted 
data type and calls ssvMakeMembTable again.

For instance, `ssvMakeMembTable(olaps)` extracts the membership table from
the mcols of a single *GRanges* object.
```{r ssvMakeMembTable basic}
head(ssvMakeMembTable(olaps))
```

## Overlapping a list of more generic data

`ssvMakeMembTable()` can handle sets defined by a list of vectors.  
These happen to be numeric but nearly anything that `as.character()` works on
should be acceptable.
```{r ssvMakeMembTable numeric}
my_set_list = list(1:3, 2:3, 3:6)
ssvMakeMembTable(my_set_list)
```
Supplying a named list is recommended
```{r ssvMakeMembTable named numeric}
names(my_set_list) = c("first", "second", "third")
ssvMakeMembTable(my_set_list)
```

A list of character vectors works just as well.
```{r ssvMakeMembTable character}
my_set_list_char = lapply(my_set_list, function(x)letters[x])
ssvMakeMembTable(my_set_list_char)
```
Notice the rownames changed as the items changed.




# Visualization of set overlaps, ssvFeature*

The ssvFeature* family of functions all accept a valid set definition and output
a ggplot.  

## Barplot
Barplots are useful for for conveying the size of each set/group.  
```{r barplot}
ssvFeatureBars(olaps)
```

## Pie chart
Pie charts are an alternative to barplots but are generally more difficult to 
interpret.
```{r pie}
ssvFeaturePie(olaps)
```

## Venn diagram
Venn diagrams show the number of items falling into each overlap category.
At release, *seqsetvis* is limited to displaying 3 sets via venn diagram. This
will be increased in a future update.
```{r venn}
ssvFeatureVenn(olaps)
```

## Euler diagram
Often confused with Venn diagrams, Euler diagrams attempt to convey the size
of each set and the degree to which the overlap with circles or ellipses of
varying sizes.  For data of any appreciable complexity, Euler diagrams are 
approximations by neccessity.

There is no limit to the number of sets *seqsetvis* can show in an Euler diagram
but computation time increases rapidly along with the inaccuracy of approximation.
```{r euler}
ssvFeatureEuler(olaps)
```

Ellipse variant of Euler diagram
```{r euler ellipse}
ssvFeatureEuler(olaps, shape = "ellipse")
```

## Binary Heatmap 

An alternative to Venn/Euler diagrams, this "heatmap" contains one column per 
set and one row per item with item membership per set mapped to color.
In this example black indicates TRUE for membership hence the top 2/3 is black
for all three sets.
```{r binary heatmap, eval = FALSE}
ssvFeatureBinaryHeatmap(olaps, raster_approximation = FALSE)
```

# Visualization of genomic signal, ssvSignal*

The ssvSignal* family of functions all take as input continuous signal data 
mapped to the genome.  This type of data is generally stored in bedGraph, 
wiggle, or bigWig format.  At this time, *seqsetvis* only directly supports the
bigWig format.  This is done via the `fetchWindowedBigwig()` and 
`fetchWindowedBigwigList()` functions.

If you don't have .bigWig (or .bigwig or .bw) files you should be able to 
easily generate some using \code{r Biocpkg("rtracklayer")} `export.bw()` alongside `import.bedGraph()`
or `import.wig()` as appropriate.

## Loading bigwig data
```{r fetchWindowedBigwig}
bigwig_files = c(
    system.file("extdata", "MCF10A_CTCF_FE_random100.bw", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10AT1_CTCF_FE_random100.bw", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10CA1_CTCF_FE_random100.bw", 
                package = "seqsetvis")
)
names(bigwig_files) = sub("_FE_random100.bw", "", basename(bigwig_files))

olap_gr = CTCF_in_10a_overlaps_gr
target_size = quantile(width(olap_gr), .75)
window_size = 50
target_size = round(target_size / window_size) * window_size
olap_gr = resize(olap_gr, target_size, fix = "center")
bw_gr = fetchWindowedBigwigList(bigwig_files, olap_gr, win_size = window_size)

bw_gr
```

Overlap information must be transformed into a factor tied to id to be useful.
```{r factorize}
olap_groups = ssvFactorizeMembTable(olap_gr)
```

## Line plots

Line plots are perhaps the most natural and common type of visualization for
this type of continuous genomic data.  Many genome browsers and other BioC 
packages support
this type of visualization.  These other approaches are very good at show
lot's of different data of multiple types at single regions.  In contrast, 
*seqsetvis* is focused on bringing in data from multiple regions simultaneously.

### Individual line plots

Basic line plot of a subset of regions
```{r lineplot basic}
ssvSignalLineplot(bw_dt = subset(bw_gr, id %in% 1:12), facet_ = "sample")
```

Facetting by region id is less overwhelming
```{r lineplot region facet}
ssvSignalLineplot(bw_dt = subset(bw_gr, id %in% 1:12), facet_ = "id")
```

### Aggregated line plots

Aggregate regions by mean 
```{r lineplot aggregated}
ssvSignalLineplotAgg(bw_dt = bw_gr)
```

Apply spline of 10 to make a prettier plot
```{r lineplot aggregated smoothed}
ssvSignalLineplotAgg(bw_dt = bw_gr, spline_n = 10)
```

By adding some info to `bw_gr`, tweaking the group_ parameter, and adding a facet 
call we can apply the aggregation function by peak call set and plot them 
separately.
```{r lineplot}
# append set info, modify aggregation group_ and add facet
olap_2groups = ssvFactorizeMembTable(ssvMakeMembTable(olap_gr)[, 1:2])
grouped_gr = GRanges(merge(bw_gr, olap_2groups))
grouped_gr = subset(grouped_gr, sample %in% c("MCF10A_CTCF", "MCF10AT1_CTCF"))
ssvSignalLineplotAgg(bw_dt = grouped_gr, spline_n = 10,
                     group_ = c("sample", "group")) + 
    facet_wrap("group", ncol = 2) +
    labs(title = "Aggregated by peak call set", y = "FE", x = "bp from center")
```

## Scatterplot

Scatterplots are a common way of viewing the relationship between two variables.
*seqsetvis* allows users to easily apply a summary function (mean by default) to 
each region as measured in two samples and plot them on the x and y axis.

A basic scatterplot
```{r scatterplot basic}
ssvSignalScatterplot(bw_gr, x_name = "MCF10A_CTCF", y_name = "MCF10AT1_CTCF")
```

Using the result of `olap_groups = ssvFactorizeMembTable(olap_gr)` to add color
based on our peak calls.
```{r scatterplot all sets}
ssvSignalScatterplot(bw_gr, x_name = "MCF10A_CTCF", y_name = "MCF10AT1_CTCF", 
                     color_table = olap_groups)
```

More than a few colors gets confusing quickly.  Let's limit the color groups to 
the samples being plotted.
```{r scatterplot 2 sets}
# by subsetting the matrix returned by ssvMakeMembTable() we have a lot of 
# control over the coloring.
olap_2groups = ssvFactorizeMembTable(ssvMakeMembTable(olap_gr)[, 1:2])
ssvSignalScatterplot(bw_gr, x_name = "MCF10A_CTCF", y_name = "MCF10AT1_CTCF", 
                     color_table = olap_2groups)
```

Coloring by the third sample's peak call might be interesting.
```{r outside group}
olap_OutGroups = ssvFactorizeMembTable(ssvMakeMembTable(olap_gr)[, 3, drop = FALSE])
ssvSignalScatterplot(bw_gr, x_name = "MCF10A_CTCF", y_name = "MCF10AT1_CTCF", color_table = olap_OutGroups)
```


We can also get clever with *ggplot2*'s facetting.
```{r scatterplot facet}
ssvSignalScatterplot(bw_gr, x_name = "MCF10A_CTCF", y_name = "MCF10AT1_CTCF", 
                     color_table = olap_groups) + facet_wrap("group")
```

## Banded quantiles

These quantile bands are a more sophisticated way to aggregate the same data 
shown in the line plots.
```{r banded quantiles}
ssvSignalBandedQuantiles(bw_gr, by_ = "sample", hsv_grayscale = TRUE, 
                         hsv_symmetric = TRUE, 
                         hsv_reverse = TRUE)
```

## Heatmap

Heatmaps combined with clustering are a powerful way to find similarly marked
regions of the genome.  Calling ssvSignalHeatmap will perform k-means clustering 
automatically.  k-means clusters sorted by similarity as determined by 
hierarchical clustering.
```{r heatmap basic}
ssvSignalHeatmap(bw_gr, nclust = 3)
```

Performing clustering manually allows for use of cluster info.
```{r heatmap perform pre-clustering}
bw_clust = ssvSignalClustering(bw_gr, nclust = 3)
bw_clust
```

Cluster selection:
```{r heatmap cluster selection}
subset(bw_clust, cluster_id == 3)
```

Plotting and pre-clustering (identical to just calling heatmap with same parameters)
```{r heatmap use pre-cluster}
ssvSignalHeatmap(bw_clust)
```


# Example: CTCF in breast cancer

CTCF binding in 3 breast cancer cell lines

## Loading Libraries

We'll use `r CRANpkg("cowplot")` to arrange our plots at the end.

```{r, message = FALSE}
library(cowplot)
```

## Loading narrowPeak files as *GRanges*

This vignette runs using a small subset of datasets that are publicly available 
via [GEO](https://www.ncbi.nlm.nih.gov/geo/).  
To download the full dataset see: [narrowPeak from GEO](#np_load)

```{r}
# set filepaths
np_files = c(
    system.file("extdata", "MCF10A_CTCF_random100.narrowPeak", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10AT1_CTCF_random100.narrowPeak", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10CA1_CTCF_random100.narrowPeak", 
                package = "seqsetvis")
)

names(np_files) = sub("_CTCF_random100.narrowPeak", "", x = basename(np_files))

# load peak calls
np_grs = easyLoad_narrowPeak(np_files)

# # Alternatively, accesss the full datasets by url.
# np_grs <- lapply(CTCF_in_10a_narrowPeak_urls, function(f){
#     import(f, format = "BED",
#            extraCols = extraCols_narrowPeak)
# })

#np_grs is now a valid input for ssvOverlapIntervalSets()
#any list (ideally with names set) of GRanges would be fine.
```

```{r}
olaps = ssvOverlapIntervalSets(np_grs)
colSums(ssvMakeMembTable(olaps))
```
### Subsetting Operations
##### bound in all 3
```{r}
length(subset(olaps, MCF10A & MCF10AT1 & MCF10CA1))
```
##### bound in all but MCF10CA1
```{r}
length(subset(olaps, MCF10A & MCF10AT1 & !MCF10CA1))
```
##### bound in MCF10CA1 (ignores the other 2)
```{r}
length(subset(olaps, MCF10CA1))
```
### Plotting

##### Total number of hits per sample
```{r, hold = TRUE, fig.align='center', fig.height=3}
p1 = ssvFeatureBars(olaps) +  theme(legend.position = "left")
p2 = ssvFeaturePie(olaps) + guides(fill = "none")
p1 = p1 + theme(axis.text.x = element_blank(), 
                axis.ticks.x = element_blank(),
                legend.justification = "center")
cowplot::ggdraw() +
    cowplot::draw_plot(p1, 0, 0, .58, .7) +
    cowplot::draw_plot(p2, 0.45, 0, 0.65, .8) +
    cowplot::draw_plot_label(c("CTCF binding in breast cancer cell lines", "A", "B"),
                             x = c(.04, .25, 0.65),
                             y = c(.92, .8, .8), size = 15, hjust = 0)
```

##### Overlaps between samples

```{r, hold = TRUE, fig.align='center', fig.width=8, fig.height=4}
p1 = ssvFeatureVenn(olaps)  +
    theme(legend.text = element_text(size = 8), 
          legend.position = "left")
p2 = ssvFeatureEuler(olaps) + 
    theme(legend.text = element_text(size = 8)) + 
    guides(fill = "none", color = "none")
p3 = ssvFeatureBinaryHeatmap(olaps) + 
    theme(axis.text.x = element_text(size = 8)) + 
    labs(title = "")
cowplot::ggdraw() +
    cowplot::draw_plot(p1 + theme(legend.justification = "center"), 0, 0, .47, 1) +
    cowplot::draw_plot(p2, 0.43, 0, 0.3, 1) +
    cowplot::draw_plot(p3, 0.75, 0, .25, 1) +
    cowplot::draw_plot_label(c("CTCF binding in breast cancer cell lines", "A", "B", "C"),
                             x = c(.04, .12, 0.43, .73),
                             y = c(.92, .8, .8, .8), size = 15, hjust = 0)
```

### Prepare overlap ranges for fetching profiles
```{r, fig.height=3}
width_q75 = quantile(width(olaps), .75)
width_q75 = ceiling(width_q75 / 100) * 100
hist_res = hist(width(olaps))
lines(rep(width_q75, 2), c(0, max(hist_res$counts)), col = "red", lwd = 5)
text(width_q75, max(hist_res$counts), "fixedSize", adj = c(-.1, 1), col = "red")
## apply width
olap_fixedSize = centerFixedSizeGRanges(olaps, width_q75)
```

### Fetch profiles
```{r}
bw_dt = CTCF_in_10a_profiles_dt
bw_gr = GRanges(bw_dt)
# reading bigWigs will not work at all on windows. if you are able to read
# bigwigs on your system, consider the following for loading as bigwigs:
# # alternative (1) accessing the subsetted bigwigs included with this package
# bw_files = sapply(names(CTCF_in_10a_bigWig_urls), function(x){
#     system.file("extdata", paste0(x, "_FE_random100.bw"), package = "seqsetvis")
# })
# bw_dt = fetchWindowedBigwigList(bw_files = bw_files, qgr = olap_fixedSize,
#   win_size = 100)

# # alternative (2) access the complete data from GEO.  has a tendency to timeout.
# bw_dt = fetchWindowedBigwigList(bw_files = CTCF_in_10a_bigWig_urls, 
#     qgr = olap_fixedSize, win_size = 100)
```
[bw load](#bw_load)

```{r, fig.width=16, fig.height=4}
p1 = ssvSignalBandedQuantiles(bw_dt, hsv_symmetric = TRUE, hsv_reverse = TRUE, 
                              hsv_grayscale = TRUE)
p2 = ssvSignalScatterplot(bw_dt, x_name = "MCF10A", y_name = "MCF10AT1")
p3 = ssvSignalHeatmap(bw_dt)
cowplot::plot_grid(p1, p2, p3, nrow = 1)
```

### Retrieve narrowPeak data by url {#np_load}
```{r, eval=FALSE}
# set file urls
np_files = CTCF_in_10a_narrowPeak_urls

# load peak calls
# from: https://charlesjb.github.io/How_to_import_narrowPeak/
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
                          qValue = "numeric", peak = "integer")
np_grs <- lapply(np_files, function(f){
    import(f, format = "BED",
           extraCols = extraCols_narrowPeak)
})
np_grs
#np_grs is now a valid input for ssvOverlapIntervalSets()
```

### Retrieve bigwig data by url {#bw_load}
```{r, eval=FALSE}
# set bigwig urls
bw_urls = CTCF_in_10a_bigWig_urls
system.file("extdata", package = "seqsetvis")
# set bigwig filenames
bw_files = paste0(names(bw_urls), "_FE.bw")
save_dir = system.file("extdata", package = "seqsetvis")
bw_files = paste(save_dir, bw_files, sep = "/")
names(bw_files) = names(bw_urls)
# download bigwigs from url to local filename
for(i in seq_along(bw_urls)){
    if(!file.exists(bw_files[i])){
        curl::curl_download(url = bw_urls[i], destfile = bw_files[i], quiet = F)
    }
}
bw_files
#bw_files is now a valid input for fetchWindowedBigwigList()
```
    
    
