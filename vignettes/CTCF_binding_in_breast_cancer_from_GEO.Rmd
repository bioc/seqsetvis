---
title: "CTCF binding in breast cancer cell lines: From GEO"
author: "Joseph R Boyd"
output:
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
vignette: >
    %\VignetteIndexEntry{CTCF binding in breast cancer cell lines: From GEO}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---
  
```{r setup, include = FALSE}
knitr::opts_chunk$set(
    collapse = TRUE
)
```

# Abstract
`r Githubpkg("jrboyd/seqsetvis")` is an R package for the visual
comparison of sets of genomic regions.  This covers straightforward overlaps 
suitable for something like a Venn diagram and extends to more sophisticated 
visualization of continous signal data via clustered heatmaps and track-like 
line plots.  

Key Features

* Mostly it "just works" with minimal assumed knowledge of R or other 
Bioconductor packages.
* All plots produced are `r CRANpkg("ggplot2")` objects. 
    + easily customized according to user preferences by appending ggplot2 functions.
    + powerful plot arrangement with with `r CRANpkg("cowplot")`, `r CRANpkg("gridExtra")`, etc.
* Although various plots are implemented, the underlying data are simple in 
structure and easily accessible so **you** can do what **you** want with them.
    + membership table for feature overlaps is just a logical matrix.
    + signal data is stored in a tidy formatted `r CRANpkg("data.table")`, ideal for `r CRANpkg("ggplot2")` visualization.
    

Although initially designed to focus on peak call sets, seqsetvis is flexile and 
accepts any data in GRanges format and is therefore flexible enough to work dowstream of 
many genomics tools.  Indeed, set comparison visualizations are genomics 
agnostic and also accept generic data types defining sets.  



This consists of 2 stages:

1. 3-way overlap of CTCF peaks in 3 cell lines to create a single merged regions 
set with 3 logical attributes.
2. Retrieval of binding profiles around merged regions set.

Both stages are supported by several plotting functions.

# Functionality Overview

## Installation and Loading

### From github
One dependency from bioconductor isn't getting installed automatically
```{r, eval=FALSE}
source("https://bioconductor.org/biocLite.R")
biocLite("GenomeInfoDbData")
```

Install devtools if needed
```{r, eval=FALSE}
if(!require(devtools)){
    install.packages("devtools")    
}
```

Install seqsetvis from github
```{r, eval=FALSE}
devtools::install_github("jrboyd/seqsetvis", build_vignettes = TRUE)
```

### Load the library
```{r}
library(seqsetvis)
```

## Defining sets
seqsetvis has several ways of accepting set information.  Since seqsetvis was 
originally intended to focus on comparing sets of peak calls, a list of 
GRanges or a GRangesList is directly supported but there are several alternatives.

### Overlapping a list of GRanges
Many functions in \code{seqsetvis} require some kind of sets definition
as input.  Sets can be defined in one of several ways.  \code{ssvOverlapIntervalSets} creates 
a single GRanges from a list of GRanges
with a logical membership table as metadata columns defining sets.
```{r}
olaps = ssvOverlapIntervalSets(CTCF_in_10a_narrowPeak_grs)
head(olaps)
```

\code{ssvOverlapIntervalSets} also accepts a GRangesList if that's more natural.
```{r}
olaps_fromGRangesList = ssvOverlapIntervalSets(GenomicRanges::GRangesList(CTCF_in_10a_narrowPeak_grs))
```

The membership data contained in the metadata columns of \code{olaps} is  
the data structure seqsetvis functions use internally.  The S4 method
\code{ssvMakeMembTable} handles the necessary conversions and can be extended 
to accept a new class of data as long as it converts to an already accepted 
data type and calls ssvMakeMembTable again.

For instance, \code{ssvMakeMembTable(olaps)} extracts the membership table from
the mcols of a single GRanges object.
```{r}
head(ssvMakeMembTable(olaps))
```

### Overlapping a list of sets containing items enumerated in vectors
```{r}
my_set_list = list(1:3, 2:3, 3:6)
ssvMakeMembTable(my_set_list)
```
Supplying a named list is recommended
```{r}
names(my_set_list) = c("first", "second", "third")
ssvMakeMembTable(my_set_list)
```

A list of character vectors works just as well.
```{r}
my_set_list_char = lapply(my_set_list, function(x)letters[x])
ssvMakeMembTable(my_set_list_char)
```
Notice the rownames changed too.




## Visualization of Overlaps, ssvFeature
The ssvFeature* family of functions all accept a valid set definition and output
a ggplot.  

### Barplot
Barplots are useful for for conveying the size of each set/group.  
```{r}
ssvFeatureBars(olaps)
```
### Pie chart
Pie charts are an alternative to barplots but are generally more difficult to 
interpret.
```{r}
ssvFeaturePie(olaps)
```

### Venn diagram
Venn diagrams show the number of items falling into each overlap category.
At release, seqsetvis is limited to displaying 3 sets via venn diagram. This
will be increased in a future update.
```{r}
ssvFeatureVenn(olaps)
```
### Euler diagram
Often confused with Venn diagrams, Euler diagrams attempt to convey the size
of each set and the degree to which the overlap with circles or ellipses of
varying sizes.  For data of any appreciable complexity, Euler diagrams are 
approximations by neccessity.
There is no limit to the number of sets seqsetvis can show in an Euler diagram
but computation time increases rapidly along with the amount of approximation.
```{r}
ssvFeatureEuler(olaps)
```

Ellipse variant of Euler diagram
```{r}
ssvFeatureEuler(olaps, shape = "ellipse")
```
### Binary Heatmap 
An alternative to Venn/Euler diagrams, this "heatmap" contains one column per 
set and one row per item with item membership per set mapped to color.
In this example black indicates TRUE for membership hence the top 2/3 is black
for all three sets.
```{r}
ssvFeatureBinaryHeatmap(olaps, raster_approximation = FALSE)
```


## Loading Libraries

```{r, message = FALSE}
# library(seqsetvis)
library(magrittr)
library(rtracklayer)
library(cowplot)
```

## Loading narrowPeak files as GRanges

This vignette runs using a small subset of datasets that are publicly available 
via [GEO](https://www.ncbi.nlm.nih.gov/geo/).  
To download the full dataset see: [narrowPeak from GEO](#np_load)

```{r}
# load 
# set filepaths
np_files = c(
    system.file("extdata", "MCF10A_CTCF_random100.narrowPeak", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10AT1_CTCF_random100.narrowPeak", 
                package = "seqsetvis"),
    system.file("extdata", "MCF10CA1_CTCF_random100.narrowPeak", 
                package = "seqsetvis")
)

names(np_files) = np_files %>%
    basename() %>%
    sub("_CTCF_random100.narrowPeak", "", x = .)

# load peak calls
# from: https://charlesjb.github.io/How_to_import_narrowPeak/
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
                          qValue = "numeric", peak = "integer")
np_grs <- lapply(np_files, function(f){
    import(f, format = "BED",
           extraCols = extraCols_narrowPeak)
})

# # Alternatively, accesss the full datasets by url.
# np_grs <- lapply(CTCF_in_10a_narrowPeak_urls, function(f){
#     import(f, format = "BED",
#            extraCols = extraCols_narrowPeak)
# })

#np_grs is now a valid input for ssvOverlapIntervalSets()
#any list (ideally with names set) of GRanges would be fine.
```

```{r}
olaps = ssvOverlapIntervalSets(np_grs)
olaps %>% mcols %>% as.data.frame %>% colSums
```
### Subsetting Operations
##### bound in all 3
```{r}
subset(olaps, MCF10A & MCF10AT1 & MCF10CA1) %>% length
```
##### bound in all but MCF10CA1
```{r}
subset(olaps, MCF10A & MCF10AT1 & !MCF10CA1) %>% length
```
##### bound in MCF10CA1 (ignores the other 2)
```{r}
subset(olaps, MCF10CA1) %>% length
```
### Plotting

##### Total number of hits per sample
```{r, hold = TRUE, fig.align='center', fig.height=3}
p1 = ssvFeatureBars(olaps) +  theme(legend.position = "left")
p2 = ssvFeaturePie(olaps) + guides(fill = "none")
p1 = p1 + theme(axis.text.x = element_blank(), 
                axis.ticks.x = element_blank(),
                legend.justification = "center")
cowplot::ggdraw() +
    cowplot::draw_plot(p1, 0, 0, .58, .7) +
    cowplot::draw_plot(p2, 0.45, 0, 0.65, .8) +
    cowplot::draw_plot_label(c("CTCF binding in breast cancer cell lines", "A", "B"),
                             x = c(.04, .25, 0.65),
                             y = c(.92, .8, .8), size = 15, hjust = 0)
```

##### Overlaps between samples

```{r, hold = TRUE, fig.align='center', fig.width=8, fig.height=4}
p1 = ssvFeatureVenn(olaps)  +
    theme(legend.text = element_text(size = 8), 
          legend.position = "left")
p2 = ssvFeatureEuler(olaps) + 
    theme(legend.text = element_text(size = 8)) + 
    guides(fill = "none", color = "none")
p3 = ssvFeatureBinaryHeatmap(olaps) + 
    theme(axis.text.x = element_text(size = 8)) + 
    labs(title = "")
cowplot::ggdraw() +
    cowplot::draw_plot(p1 + theme(legend.justification = "center"), 0, 0, .47, 1) +
    cowplot::draw_plot(p2, 0.43, 0, 0.3, 1) +
    cowplot::draw_plot(p3, 0.75, 0, .25, 1) +
    cowplot::draw_plot_label(c("CTCF binding in breast cancer cell lines", "A", "B", "C"),
                             x = c(.04, .12, 0.43, .73),
                             y = c(.92, .8, .8, .8), size = 15, hjust = 0)
```

### Prepare overlap ranges for fetching profiles
```{r, fig.height=3}
width_q75 = olaps %>% width() %>% quantile(., .75)
width_q75 = ceiling(width_q75 / 100) * 100
hist_res = hist(width(olaps))
lines(rep(width_q75, 2), c(0, max(hist_res$counts)), col = "red", lwd = 5)
text(width_q75, max(hist_res$counts), "fixedSize", adj = c(-.1, 1), col = "red")
## apply width
olap_fixedSize = centerFixedSizeGRanges(olaps, width_q75)
```

### Fetch profiles
```{r}
bw_dt = CTCF_in_10a_profiles_dt
bw_gr = GRanges(bw_dt)
# reading bigWigs will not work at all on windows. if you are able to read
# bigwigs on your system, consider the following for loading as bigwigs:
# # alternative (1) accessing the subsetted bigwigs included with this package
# bw_files = sapply(names(CTCF_in_10a_bigWig_urls), function(x){
#     system.file("extdata", paste0(x, "_FE_random100.bw"), package = "seqsetvis")
# })
# bw_dt = fetchWindowedBigwigList(bw_files = bw_files, qgr = olap_fixedSize,
#   win_size = 100)

# # alternative (2) access the complete data from GEO.  has a tendency to timeout.
# bw_dt = fetchWindowedBigwigList(bw_files = CTCF_in_10a_bigWig_urls, 
#     qgr = olap_fixedSize, win_size = 100)
```
[bw load](#bw_load)

```{r, fig.width=16, fig.height=4}
p1 = ssvSignalBandedQuantiles(bw_dt, hsv_symmetric = TRUE, hsv_reverse = TRUE, 
                              hsv_grayscale = TRUE)
p2 = ssvSignalScatterplot(bw_dt, x_name = "MCF10A", y_name = "MCF10AT1")
p3 = ssvSignalHeatmap(bw_dt)
cowplot::plot_grid(p1, p2, p3, nrow = 1)
```

### Retrieve narrowPeak data by url {#np_load}
```{r, eval=FALSE}
# set file urls
np_files = CTCF_in_10a_narrowPeak_urls

# load peak calls
# from: https://charlesjb.github.io/How_to_import_narrowPeak/
extraCols_narrowPeak <- c(signalValue = "numeric", pValue = "numeric",
                          qValue = "numeric", peak = "integer")
np_grs <- lapply(np_files, function(f){
    import(f, format = "BED",
           extraCols = extraCols_narrowPeak)
})
np_grs
#np_grs is now a valid input for ssvOverlapIntervalSets()
```

### Retrieve bigwig data by url {#bw_load}
```{r, eval=FALSE}
# set bigwig urls
bw_urls = CTCF_in_10a_bigWig_urls
system.file("extdata", package = "seqsetvis")
# set bigwig filenames
bw_files = paste0(names(bw_urls), "_FE.bw")
save_dir = system.file("extdata", package = "seqsetvis")
bw_files = paste(save_dir, bw_files, sep = "/")
names(bw_files) = names(bw_urls)
# download bigwigs from url to local filename
for(i in seq_along(bw_urls)){
    if(!file.exists(bw_files[i])){
        curl::curl_download(url = bw_urls[i], destfile = bw_files[i], quiet = F)
    }
}
bw_files
#bw_files is now a valid input for fetchWindowedBigwigList()
```
